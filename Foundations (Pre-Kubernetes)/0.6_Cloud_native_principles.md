üåê 0.6 Cloud-Native Principles: 12-Factor App & Microservices

    This topic is essential because Kubernetes (and clout-native in general) is designed to run cloud-native
    applications -- and understanding the philosophy behind them is critical.

    ‚úÖ What is ‚ÄúCloud-Native‚Äù?

        * Cloud-native is an approach to building and running applications that:
            - Are resilient
            - Can be scaled easily
            - Can be updated frequently
            - Run will in cloud environments
        
        * They follow a set of principles that help them thrive in dynamic, containerized systems like kubernetes.

    üîπ Part 1: The 12-Factor App Methodology

        * The 12-Factor App is a set of best practices for building modern web apps, especially SaaS (Software as a Service) apps.

            1. Codebase

                * One codebase tracked in version control, many deploys.
                    - Use Git.
                    - Don't duplicate codebases per environment.
                    - Example :-
                        - One GitHub repo -> Dev + Staging + Production deployments.

            2. Dependencies

                * Explicitly declare and isolate dependencies.
                * This means your app should not assume anything is globally available on the host (like libraries, SDKs, or tools).
                  Instead, your app must declare what it needs, and those dependencies should be installed in isolation (not system-wide)

                    - Use a dependency manager like:
                        - requirements.txt (Python)
                        - package.json (Node.js)
                        - go.md (Go)
                    
                    - üê≥ In Docker ‚Äì Isolating Dependencies

                        Let's say you are containerizing your ASP.NET Core app.

                        Dockerfile :-

                            FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
                            WORKDIR /app
                            EXPOSE 80

                            FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
                            WORKDIR /src
                            COPY ["MyProductApi/MyProductApi.csproj", "MyProductApi/"]
                            RUN dotnet restore "MyProductApi/MyProductApi.csproj"  # üëà RESTORE dependencies

                            COPY . .
                            WORKDIR "/src/MyProductApi"
                            RUN dotnet build "MyProductApi.csproj" -c Release -o /app/build
                            RUN dotnet publish "MyProductApi.csproj" -c Release -o /app/publish

                            FROM base AS final
                            WORKDIR /app
                            COPY --from=build /app/publish .
                            ENTRYPOINT ["dotnet", "MyProductApi.dll"]

                            - Explicitly declares dependencies in .csproj
                            - dotnet restore installs them in isolated container context
                            - Does not rely on global libraries from the host system.

                    üåê In Kubernetes Context

                        * When deployed in Kubernetes
                            - Your app runs in a Pod.
                            - The Docker image includes only what your app needs.
                            - All dependencies are inside the container.

                        * This aligns with:
                            - Portability
                            - Repeatability
                            - Dev/Prod parity


            3. Config

                * Store config in the environment.

                    - Store secrets/API keys in:
                        - Environment variables
                        - Kubernetes Secrets
                    - Example:

                        export DATABASE_URL=postgres://user:pass@host:port/db

            üß© 4. Backing Services ‚Äì In-Depth (ASP.NET Core)

                