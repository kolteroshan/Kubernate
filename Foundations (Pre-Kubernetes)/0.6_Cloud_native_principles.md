ðŸŒ 0.6 Cloud-Native Principles: 12-Factor App & Microservices

    This topic is essential because Kubernetes (and clout-native in general) is designed to run cloud-native
    applications -- and understanding the philosophy behind them is critical.

    âœ… What is â€œCloud-Nativeâ€?

        * Cloud-native is an approach to building and running applications that:
            - Are resilient
            - Can be scaled easily
            - Can be updated frequently
            - Run will in cloud environments
        
        * They follow a set of principles that help them thrive in dynamic, containerized systems like kubernetes.

    ðŸ”¹ Part 1: The 12-Factor App Methodology

        * The 12-Factor App is a set of best practices for building modern web apps, especially SaaS (Software as a Service) apps.

            1. Codebase

                * One codebase tracked in version control, many deploys.
                    - Use Git.
                    - Don't duplicate codebases per environment.
                    - Example :-
                        - One GitHub repo -> Dev + Staging + Production deployments.

            2. Dependencies

                * Explicitly declare and isolate dependencies.
                * This means your app should not assume anything is globally available on the host (like libraries, SDKs, or tools).
                  Instead, your app must declare what it needs, and those dependencies should be installed in isolation (not system-wide)

                    - Use a dependency manager like:
                        - requirements.txt (Python)
                        - package.json (Node.js)
                        - go.md (Go)
                    
                    - ðŸ³ In Docker â€“ Isolating Dependencies

                        Let's say you are containerizing your ASP.NET Core app.

                        Dockerfile :-

                            FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
                            WORKDIR /app
                            EXPOSE 80

                            FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
                            WORKDIR /src
                            COPY ["MyProductApi/MyProductApi.csproj", "MyProductApi/"]
                            RUN dotnet restore "MyProductApi/MyProductApi.csproj"  # ðŸ‘ˆ RESTORE dependencies

                            COPY . .
                            WORKDIR "/src/MyProductApi"
                            RUN dotnet build "MyProductApi.csproj" -c Release -o /app/build
                            RUN dotnet publish "MyProductApi.csproj" -c Release -o /app/publish

                            FROM base AS final
                            WORKDIR /app
                            COPY --from=build /app/publish .
                            ENTRYPOINT ["dotnet", "MyProductApi.dll"]

                            - Explicitly declares dependencies in .csproj
                            - dotnet restore installs them in isolated container context
                            - Does not rely on global libraries from the host system.

                    ðŸŒ In Kubernetes Context

                        * When deployed in Kubernetes
                            - Your app runs in a Pod.
                            - The Docker image includes only what your app needs.
                            - All dependencies are inside the container.

                        * This aligns with:
                            - Portability
                            - Repeatability
                            - Dev/Prod parity


            3. Config

                * Store config in the environment.

                    - Store secrets/API keys in:
                        - Environment variables
                        - Kubernetes Secrets
                    - Example:

                        export DATABASE_URL=postgres://user:pass@host:port/db

            4. Backing Services

                * Treat backing services as attached resources.

                    - DBs, caches, queues are services, not part of the app.
                    - You can swap them without code changes.
                    - Example
                        - Switch Redis -> Memcached
                        - Switch PostgreSQL -> MySQL

                

                * Your application should treat external services (like databases, message queues, storage, etc) as pluggable
                  components, not hard-coded parts of the app.

                  These services should:

                    * Be accessed via a URL or environment variable
                    * Be interchangeable without changing application code.

                ðŸ“¦ What is a "Backing Service"?

                    A backing service is any service your app uses over the network - typically via a URL, connection string, or port.

            5. Build, Release, Run

                * Strictly separate build and run stages.

                    1. Build: Compile code -> Docker image
                    2. Release: Add config (env vars)
                    3. Run: Start the app
                    * Kubernetes + CI/CD (e.g., GitHub Actions) does this well.


                1. Build Stage

                    * Goal: Turn your source code into a runnable artifact.

                    In ASP.NET Core
                        - You take your .cs file, .csproj project file, Razor views, etc.
                        - You use the .NET SDK to compile them into DLLs
                        - It must not depend on secrets or production configs yet.

                2. Release Stage

                    * Goal: Combine the build artifact with environment-specific configuration.

                    In ASP.NET Core
                        - You don't change the compiled DLL - you just prepare configs.
                        - Config comes from:
                            - Environment variables (via IConfiguration)
                            - appsettings.Production.json
                            - Secrets from Azure Key Vault, Kubernetes Secrets, etc.
                        - This is where you tell your app things like
                            - Which database to connect to
                            - API keys for payment services
                            - Logging levels
                        - The same build can be released to different environments (Dev, QA, Prod) by just changing config.

                3. Run Stage

                    * Goal: Actually execute the application with its runtime.
                        - Uses .NET Runtime, not SDK.

            6. Processes

                Execute the app as one or more stateless processes.

                    * Don't store state (like files, sessions) in the app.
                    * Use DBs, caches, volumes.
                    * Example:
                        - Bad: Saving file to /temp/file.jpg
                        - Good: Upload to S3 or use volume.

            7. Port Binding

                Export services via port binding

                    * App should listen on a port
                    * Kubernetes ses 'Services' to expose these.
                    * Make the application self-contained by exposing services via a port.
                    * ASP.NET Core apps don't need IIS by default- they have Kestrel, a built-in cross platform web server.
                    * Your app starts listening for requests on a port you define.
                    * The OS, Docker, or Kubernetes then routes traffic to that port.

            8. Concurrency

                Scale out via the process model.

                    * Horizontal scaling (multiple replicas)
                        * Web, worker, cron all run separately.
            
            9. Disposability

                Fast startup and graceful shutdown.

                    * Cntainers should start/stop quickly.
                    * Respond to SIGTERM to shut down cleanly.
                    * Example
                        - Log completion
                        - Close DB connection
                        - Exit

            10. Dev/Prod Parity

                Keep development, staging, and production as similar as possible.

                    - Use same
                        - OS
                        - Dependencies
                        - Config strcture
                    - Tools: Docker, Kubernetes namespaces

            11. Logs

                Treat logs as event streams.

                    - Output logs to stdout/stderr
                    - Don't write files!
                    - Kubernetes handles logs:

            12. Admin Processes

                Run admin/management tasks as one-off processes.

                    * Use CLI tools inside container
                    * In Kubernetes
                        Run as a Job or kubectl exec into pod.

                Instead of baking admin jobs permanently into your app's main process, run them on demand as separate
                processes when needed.
                Example:- database migrations, data cleanup, re-indexing search data, bluk import, etc.

            